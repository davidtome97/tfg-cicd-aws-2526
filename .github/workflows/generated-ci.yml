name: CI-tfg-cicd-aws-2526

# -----------------------------
# Disparadores del workflow
# -----------------------------
# Aquí defino cuándo quiero que se ejecute mi pipeline en GitHub Actions.
# Dejo push, tags y PR opcional.

# Primero calculo una sola vez la condición de despliegue que luego reutilizo.




on:
  push:
    branches:

      - "main"

    tags:
      - "*"


  pull_request:
    branches:

      - "main"



jobs:


  # ======================================================
  # JOB: Build & Test Java (Maven)
  # ======================================================
  build_and_test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Java (Temurin 17)
        # Uso Java 17 para compilar mi proyecto.
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: Build & Test (Maven)
        run: ./mvnw -B -f pom.xml test


  # ======================================================
  # JOB: SonarCloud
  # ======================================================
  sonar:
    runs-on: ubuntu-latest
    needs:
      - build_and_test


    steps:
      - uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: SonarCloud Analysis
        # Aquí ejecuto el análisis de calidad con SonarCloud.
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
          SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
        run: |
          ./mvnw -B verify sonar:sonar \
            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
            -Dsonar.organization=${SONAR_ORGANIZATION} \
            -Dsonar.host.url=${SONAR_HOST_URL}



  # ======================================================
  # JOB: Deploy a AWS ECR (Build & Push Docker)
  # ======================================================
  deploy:
    runs-on: ubuntu-latest
    needs:
      - build_and_test


      - sonar

    # Modo de despliegue (reutilizo la misma condición en todos los deploys).
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - uses: actions/checkout@v4

      - name: Configurar credenciales AWS
        # Aquí hago login en AWS con un usuario IAM que tiene permisos en ECR/EC2.
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push Docker
        # Aquí construyo la imagen Docker y la subo a ECR con dos tags: SHA y latest.
        env:
          ECR_REGISTRY: ${{ secrets.AWS_ECR_URL }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "Construyendo imagen $IMAGE_URI"

          docker build -t "$IMAGE_URI" .

          # También publico una etiqueta 'latest' para que la EC2 tire siempre de la última versión.
          docker tag "$IMAGE_URI" "$ECR_REGISTRY/$ECR_REPOSITORY:latest"

          docker push "$IMAGE_URI"
          docker push "$ECR_REGISTRY/$ECR_REPOSITORY:latest"

          echo "Imágenes publicadas correctamente en ECR"

  # ======================================================
  # JOB: Deploy en EC2
  # ======================================================
  deploy_ec2:
    runs-on: ubuntu-latest
    needs: deploy
    # Reutilizo exactamente la misma condición de despliegue que en 'deploy'.
    if: startsWith(github.ref, 'refs/tags/')

    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ECR_URL: ${{ secrets.AWS_ECR_URL }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      EC2_HOST: ${{ secrets.EC2_HOST }}
      EC2_USER: ${{ secrets.EC2_USUARIO }}
      EC2_LLAVE_SSH: ${{ secrets.EC2_LLAVE_SSH }}
      EC2_KNOWN_HOSTS: ${{ secrets.EC2_KNOWN_HOSTS }}

    steps:
      - uses: actions/checkout@v4

      - name: Preparar clave SSH
        # Aquí preparo la clave privada y el known_hosts para poder conectarme por SSH.
        run: |
          mkdir -p ~/.ssh
          printf "%s" "${EC2_LLAVE_SSH}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          if [ -n "${EC2_KNOWN_HOSTS}" ]; then
            echo "${EC2_KNOWN_HOSTS}" > ~/.ssh/known_hosts
          else
            ssh-keyscan -H "$EC2_HOST" >> ~/.ssh/known_hosts
          fi

      - name: Subir docker-compose.yml a EC2
        run: scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes docker-compose.yml "$EC2_USER@$EC2_HOST:~/app/docker-compose.yml"

      - name: Ejecutar despliegue en EC2
        # Aquí hago el pull de la imagen y levanto los contenedores en la EC2.
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "$EC2_USER@$EC2_HOST" "
            set -e

            export AWS_REGION='${AWS_REGION}'
            export AWS_ECR_URL='${AWS_ECR_URL}'
            export ECR_REPOSITORY='${ECR_REPOSITORY}'

            # Aquí reconstruyo el host del registry a partir de la URL de ECR.
            REGISTRY_NO_PROTO=\"\${AWS_ECR_URL#https://}\"
            REGISTRY_HOST=\"\${REGISTRY_NO_PROTO%/}\"

            # Y aquí construyo IMAGE_URI, que es lo que usa mi docker-compose.yml.
            export IMAGE_URI=\"\${REGISTRY_HOST}/\${ECR_REPOSITORY}:latest\"

            echo 'Haciendo login en ECR desde la EC2'
            aws ecr get-login-password --region \"${AWS_REGION}\" \
              | docker login --username AWS --password-stdin \"\${REGISTRY_HOST}\"

            cd ~/app
            docker compose pull
            docker compose up -d --remove-orphans
            docker image prune -f
          "
