name: Despliegue a EC2

on:
  workflow_dispatch:              # Lo puedo lanzar a mano desde Actions.
    inputs:
      etiqueta_imagen:
        description: "Etiqueta de la imagen Docker "
        required: false
  push:
    tags:
      # También se dispara cuando creo un tag tipo v0.1.0.
      - "v*.*.*"

permissions:
  contents: read

jobs:
  deployar:
    name: Deploy a EC2
    runs-on: ubuntu-latest

    steps:
      # Traigo el código del repo para tener el Dockerfile y el compose.
      - name: Checkout
        uses: actions/checkout@v4

      # ahora configuro las credenciales de AWS para poder usar ECR desde el runner.
      - name: Configurar AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # despues hago login en ECR en el runner para poder hacer push de la imagen.
      - name: Login en ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      # en esta parte me aseguro de que el repositorio de ECR exista; si no, lo creo.
      - name: Asegurar repositorio ECR
        run: |
          REGISTRO="${{ steps.ecr.outputs.registry }}"
          REPO="${{ github.repository }}"
          echo "Verificando repositorio ECR: $REPO"
          aws ecr describe-repositories --repository-names "$REPO" >/dev/null 2>&1 \
          || aws ecr create-repository --repository-name "$REPO" >/dev/null
          echo "Repositorio ECR listo: $REPO (Registry: $REGISTRO)"

      # creo/calculo la etiqueta que voy a usar para la imagen.
      #    Si no me pasan nada por input, uso el nombre del tag del push.
      - name: Calcular etiqueta
        id: vars
        run: |
          if [ -z "${{ github.event.inputs.etiqueta_imagen }}" ]; then
            echo "etiqueta=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          else
            echo "etiqueta=${{ github.event.inputs.etiqueta_imagen }}" >> $GITHUB_OUTPUT
          fi

      # ya construyo la imagen y la subo a ECR usando el Dockerfile de la raíz.
      - name: Build y push de imagen
        id: push
        run: |
          REGISTRO="${{ steps.ecr.outputs.registry }}"
          REPO="${{ github.repository }}"   # owner/proyecto
          IMAGEN="$REGISTRO/$REPO:${{ steps.vars.outputs.etiqueta }}"
          echo "Construyendo imagen: $IMAGEN"
          docker build -t "$IMAGEN" .
          docker push "$IMAGEN"
          echo "imagen=$IMAGEN" >> $GITHUB_OUTPUT

      # copio el docker-compose que uso para el deploy a la EC2 (lo dejo en ~/app/).
      - name: Copiar docker-compose.yml a EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USUARIO }}
          key: ${{ secrets.EC2_LLAVE_SSH }}
          source: "infra/ec2/docker-compose.yml"
          target: "~/app"
          strip_components: 2
          overwrite: true       # Si ya existe, lo sobreescribo.
          timeout: 120s         # Un poco más de margen por si la red va lenta.

      # aqui me conecto por SSH a la EC2, hago login en ECR allí y levanto el docker-compose.
      - name: Ejecutar deploy en EC2
        uses: appleboy/ssh-action@v1.0.3
        # le paso las credenciales de AWS como variables de entorno al script de la EC2.
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USUARIO }}
          key: ${{ secrets.EC2_LLAVE_SSH }}
          envs: AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_REGION
          script: |
            set -e
            mkdir -p ~/app
            cd ~/app

            # Instalo AWS CLI en la EC2 solo la primera vez si todavía no está.
            if ! command -v aws >/dev/null 2>&1; then
              echo "Instalando AWS CLI en la EC2..."
              sudo apt-get update -y
              sudo apt-get install -y unzip >/dev/null
              curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install
              rm -rf aws awscliv2.zip
            fi
            aws --version

            # Hago login en ECR dentro de la EC2 usando las credenciales que he pasado.
            REGISTRY="${{ steps.ecr.outputs.registry }}"
            echo "Login en ECR: $REGISTRY"
            aws ecr get-login-password --region "$AWS_REGION" \
              | docker login --username AWS --password-stdin "$REGISTRY"

            # Imagen que he publicado en el paso anterior del workflow.
            export IMAGEN="${{ steps.push.outputs.imagen }}"
            echo "Usando imagen: $IMAGEN"

            # Por si el compose se ha quedado dentro de carpetas, me aseguro de tenerlo plano.
            test -f docker-compose.yml || { 
              if [ -f infra/ec2/docker-compose.yml ]; then
                mv infra/ec2/docker-compose.yml docker-compose.yml && rm -rf infra;
              else
                echo "ERROR: no se encuentra docker-compose.yml en ~/app"; exit 1;
              fi
            }

            # Actualizo el .env con la imagen que quiero desplegar.
            grep -v '^IMAGEN=' .env 2>/dev/null | cat > .env.tmp || true
            echo "IMAGEN=$IMAGEN" >> .env.tmp
            mv .env.tmp .env

            # Actualizo los contenedores con docker compose y levanto la nueva versión.
            docker compose pull
            docker compose up -d

            # Limpio imágenes antiguas para no llenar el disco de la instancia.
            docker image prune -f