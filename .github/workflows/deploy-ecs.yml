name: Despliegue a EC2

on:
  workflow_dispatch:              # lo puedo lanzar a mano desde Actions
    inputs:
      etiqueta_imagen:
        description: "Etiqueta de la imagen Docker (opcional)"
        required: false
  push:
    tags:
      - "v*.*.*"                  # también se dispara al crear un tag tipo v0.1.0

permissions:
  contents: read

jobs:
  deployar:
    name: Deploy a EC2
    runs-on: ubuntu-latest

    steps:
      # 1) Traigo el código del repo
      - name: Checkout
        uses: actions/checkout@v4

      # 2) Credenciales AWS para usar ECR desde el runner
      - name: Configurar AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 3) Login en ECR (en el runner) para poder hacer push
      - name: Login en ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 4) Me aseguro de que el repo ECR existe (si no, lo creo)
      - name: Asegurar repositorio ECR
        run: |
          REGISTRO="${{ steps.ecr.outputs.registry }}"
          REPO="${{ github.repository }}"
          echo "Verificando repositorio ECR: $REPO"
          aws ecr describe-repositories --repository-names "$REPO" >/dev/null 2>&1 \
          || aws ecr create-repository --repository-name "$REPO" >/dev/null
          echo "Repositorio ECR listo: $REPO (Registry: $REGISTRO)"

      # 5) Calculo etiqueta de la imagen (si no paso input, uso el tag del push)
      - name: Calcular etiqueta
        id: vars
        run: |
          if [ -z "${{ github.event.inputs.etiqueta_imagen }}" ]; then
            echo "etiqueta=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          else
            echo "etiqueta=${{ github.event.inputs.etiqueta_imagen }}" >> $GITHUB_OUTPUT
          fi

      # 6) Build + push de la imagen a ECR (con Dockerfile de la raíz)
      - name: Build y push de imagen
        id: push
        run: |
          REGISTRO="${{ steps.ecr.outputs.registry }}"
          REPO="${{ github.repository }}"   # owner/proyecto
          IMAGEN="$REGISTRO/$REPO:${{ steps.vars.outputs.etiqueta }}"
          echo "Construyendo imagen: $IMAGEN"
          docker build -t "$IMAGEN" .
          docker push "$IMAGEN"
          echo "imagen=$IMAGEN" >> $GITHUB_OUTPUT

      # 7) Copio el docker-compose del deploy a la EC2 (lo dejo en ~/app/)
      - name: Copiar docker-compose.yml a EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USUARIO }}
          key: ${{ secrets.EC2_LLAVE_SSH }}
          source: "infra/ec2/docker-compose.yml"
          target: "~/app"
          strip_components: 2    # quito "infra/ec2" y dejo el archivo plano en ~/app/
          overwrite: true        # si ya está, lo sobrescribo
          timeout: 120s          # más margen por si la red va lenta

      # 8) Me conecto por SSH a la EC2, hago login en ECR allí y levanto el compose
      - name: Ejecutar deploy en EC2
        uses: appleboy/ssh-action@v1.0.3
        # le paso las creds AWS al paso SSH para que la EC2 pueda loguearse en ECR
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USUARIO }}
          key: ${{ secrets.EC2_LLAVE_SSH }}
          envs: AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_REGION
          script: |
            set -e
            mkdir -p ~/app
            cd ~/app

            # (una sola vez) Instalo AWS CLI si no está
            if ! command -v aws >/dev/null 2>&1; then
              echo "Instalando AWS CLI en la EC2..."
              sudo apt-get update -y
              sudo apt-get install -y unzip >/dev/null
              curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install
              rm -rf aws awscliv2.zip
            fi
            aws --version

            # Login en ECR con las creds que acabo de pasar como envs
            REGISTRY="${{ steps.ecr.outputs.registry }}"
            echo "Login en ECR: $REGISTRY"
            aws ecr get-login-password --region "$AWS_REGION" \
              | docker login --username AWS --password-stdin "$REGISTRY"

            # Imagen publicada en el paso de build
            export IMAGEN="${{ steps.push.outputs.imagen }}"
            echo "Usando imagen: $IMAGEN"

            # Por si el compose llegó dentro de carpetas, lo plano en ~/app
            test -f docker-compose.yml || { 
              if [ -f infra/ec2/docker-compose.yml ]; then
                mv infra/ec2/docker-compose.yml docker-compose.yml && rm -rf infra;
              else
                echo "ERROR: no se encuentra docker-compose.yml en ~/app"; exit 1;
              fi
            }

            # Actualizo .env con la imagen que quiero desplegar (simple y explícito)
            grep -v '^IMAGEN=' .env 2>/dev/null | cat > .env.tmp || true
            echo "IMAGEN=$IMAGEN" >> .env.tmp
            mv .env.tmp .env

            # Pull y arranque del contenedor
            docker compose pull
            docker compose up -d

            # Limpieza de imágenes antiguas para ahorrar disco
            docker image prune -f