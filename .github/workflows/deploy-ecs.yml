name: Despliegue a EC2

on:
  workflow_dispatch:              # permite lanzarlo manualmente desde Actions
    inputs:
      etiqueta_imagen:
        description: "Etiqueta de la imagen Docker (opcional)"
        required: false
  push:
    tags:
      - "v*.*.*"                  # también se ejecuta al crear un tag tipo v0.1.0

permissions:
  contents: read

jobs:
  deployar:
    name: Deploy a EC2
    runs-on: ubuntu-latest

    steps:
      # 1 Traigo el codigo del repo
      - name: Checkout
        uses: actions/checkout@v4

      # 2 Configuro credenciales de AWS para poder usar ECR
      - name: Configurar AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 3 Login en ECR (registro de contenedores de AWS)
      - name: Login en ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 4 me aseguro que el repositorio ECR exista, si no lo creamos
      - name: Asegurar repositorio ECR
        run: |
          REGISTRO="${{ steps.ecr.outputs.registry }}"
          REPO="${{ github.repository }}"
          echo "Verificando repositorio ECR: $REPO"
          aws ecr describe-repositories --repository-names "$REPO" >/dev/null 2>&1 \
          || aws ecr create-repository --repository-name "$REPO" >/dev/null
          echo "Repositorio ECR listo: $REPO (Registry: $REGISTRO)"

      # 5 Calculo la etiqueta de la imagen (usa input o el tag del push)
      - name: Calcular etiqueta
        id: vars
        run: |
          if [ -z "${{ github.event.inputs.etiqueta_imagen }}" ]; then
            echo "etiqueta=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          else
            echo "etiqueta=${{ github.event.inputs.etiqueta_imagen }}" >> $GITHUB_OUTPUT
          fi

      # 6 Construyo y subo la imagen Docker a ECR
      - name: Build y push de imagen
        id: push
        run: |
          REGISTRO="${{ steps.ecr.outputs.registry }}"
          REPO="${{ github.repository }}"   # owner/proyecto
          IMAGEN="$REGISTRO/$REPO:${{ steps.vars.outputs.etiqueta }}"
          echo "Construyendo imagen: $IMAGEN"
          docker build -t "$IMAGEN" .
          docker push "$IMAGEN"
          echo "imagen=$IMAGEN" >> $GITHUB_OUTPUT

      # 7 Copio el docker-compose.yml al servidor EC2
      - name: Copiar docker-compose.yml a EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USUARIO }}
          key: ${{ secrets.EC2_LLAVE_SSH }}
          source: "infra/ec2/docker-compose.yml"
          target: "~/app"
          strip_components: 2   # quito "infra/ec2" y deja el archivo en ~/app/
          overwrite: true
          timeout: 120s

      # 8 Conecto por SSH y levanto el contenedor
      - name: Ejecutar deploy en EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USUARIO }}
          key: ${{ secrets.EC2_LLAVE_SSH }}
          script: |
            set -e
            mkdir -p ~/app
            cd ~/app
            # Imagen publicada en ECR
            export IMAGEN="${{ steps.push.outputs.imagen }}"
            echo "Usando imagen: $IMAGEN"

            # Actualizo .env con la nueva imagen
            grep -v '^IMAGEN=' .env 2>/dev/null | cat > .env.tmp || true
            echo "IMAGEN=$IMAGEN" >> .env.tmp
            mv .env.tmp .env

            # Pull de la imagen y arranque del contenedor
            docker compose pull
            docker compose up -d

            # Limpieza de imágenes antiguas
            docker image prune -f