name: CI-{{ config.project_name }}

# Aquí dejo definido el nombre del workflow usando el nombre del proyecto que pasé en el formulario.

# En esta parte calculo una variable interna (deploy_condition) que luego reutilizo
# para simplificar el código de las condiciones de despliegue.
# De esta forma no tengo que repetir la expresión en cada job.
{% if config.deploy_mode == 'tag' %}
{%   set deploy_condition = "startsWith(github.ref, 'refs/tags/')" %}
{% elif config.deploy_mode == 'main' %}
{%   set deploy_condition = "github.ref == 'refs/heads/main'" %}
{% elif config.deploy_mode == 'manual' %}
{%   set deploy_condition = "github.event_name == 'workflow_dispatch'" %}
{% else %}
{%   set deploy_condition = "true" %}
{% endif %}

on:
  push:
    branches:
{% for b in config.branches %}
      # Aquí añado las ramas que quiero que activen la pipeline cuando hago push.
      - "{{ b }}"
{% endfor %}
    # También dejo activado para que se ejecute en cualquier tag.
    tags:
      - "*"

{% if config.run_on_pr %}
  pull_request:
    branches:
{%   for b in config.branches %}
      # Si he marcado la opción de ejecutarse en PR, dejo las mismas ramas.
      - "{{ b }}"
{%   endfor %}
{% endif %}

  # También permito ejecutar la pipeline manualmente desde la UI de GitHub.
  workflow_dispatch:

jobs:
{% if config.use_node %}

  # Job opcional de Node.js (solo lo genero si el proyecto lo necesita).
  # Lo uso para instalar dependencias, ejecutar tests y el linter si lo tengo.
  node_build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        # Instalo Node 20 porque es la versión recomendada ahora mismo.
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Instalar dependencias (npm install)
        run: npm install

      - name: Ejecutar tests Node
        # Si no tengo tests no quiero que me reviente la pipeline, así que ignoro el error.
        run: npm test || echo "No tengo tests de Node configurados, continúo."

      - name: Linter (npm run lint)
        # Solo ejecuto lint si existe el script en package.json.
        run: |
          if npm run | grep -q lint; then
            npm run lint
          else
            echo "No tengo script de lint, lo salto."
          fi
{% endif %}

  # Job principal de Java/Maven. Aquí compilo y ejecuto los tests del backend.
  build_and_test:
    runs-on: ubuntu-latest
{% if config.use_node %}
    # Si tengo Node, primero necesito generar el frontend, así que lo pongo como dependencia.
    needs: node_build
{% endif %}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Java (Temurin 17)
        # Uso Java 17 porque es la versión LTS más utilizada en entornos actuales.
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: Build & Test (Maven)
        # Aquí lanzo Maven con los tests.
        run: ./mvnw -B -f pom.xml test

{% if config.use_sonar %}

  # Job de SonarCloud. Lo dejo separado para que solo dependa del build.
  sonar:
    runs-on: ubuntu-latest
    needs:
      - build_and_test
{%   if config.use_node %}
      - node_build
{%   endif %}
{%   if not config.fail_on_sonar %}
    # Si no quiero que Sonar rompa la pipeline, activo continue-on-error.
    continue-on-error: true
{%   endif %}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Java
        # Sonar utiliza Java, así que vuelvo a configurar Java 17.
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: SonarCloud Analysis
        # Ejecuto el análisis de calidad desde Maven.
        env:
          SONAR_TOKEN: {% raw %}${{ secrets.SONAR_TOKEN }}{% endraw %}
          SONAR_HOST_URL: {% raw %}${{ secrets.SONAR_HOST_URL }}{% endraw %}
          SONAR_PROJECT_KEY: {% raw %}${{ secrets.SONAR_PROJECT_KEY }}{% endraw %}
          SONAR_ORGANIZATION: {% raw %}${{ secrets.SONAR_ORGANIZATION }}{% endraw %}
        run: |
          ./mvnw -B verify sonar:sonar \
            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
            -Dsonar.organization=${SONAR_ORGANIZATION} \
            -Dsonar.host.url=${SONAR_HOST_URL}
{% endif %}

{% if config.use_aws %}

  # Job para construir la imagen Docker y subirla a ECR.
  deploy:
    runs-on: ubuntu-latest
    needs:
      - build_and_test
{%   if config.use_node %}
      - node_build
{%   endif %}
{%   if config.use_sonar %}
      - sonar
{%   endif %}
    # Solo despliego si se cumple la condición configurada en el formulario.
    if: {{ deploy_condition }}

    steps:
      - uses: actions/checkout@v4

      - name: Configurar credenciales AWS
        # Aquí hago login en AWS con un IAM que solo usa ECR/EC2 para despliegues.
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: {% raw %}${{ secrets.AWS_ACCESS_KEY_ID }}{% endraw %}
          aws-secret-access-key: {% raw %}${{ secrets.AWS_SECRET_ACCESS_KEY }}{% endraw %}
          aws-region: {% raw %}${{ secrets.AWS_REGION }}{% endraw %}

      - name: Login ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push Docker
        # Construyo la imagen, la taggeo con el commit y con 'latest', y la subo a ECR.
        env:
          ECR_REGISTRY: {% raw %}${{ secrets.AWS_ECR_URL }}{% endraw %}
          ECR_REPOSITORY: {% raw %}${{ secrets.ECR_REPOSITORY }}{% endraw %}
          IMAGE_TAG: {% raw %}${{ github.sha }}{% endraw %}
        run: |
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "Construyendo imagen $IMAGE_URI"

          docker build -t "$IMAGE_URI" .
          docker tag "$IMAGE_URI" "$ECR_REGISTRY/$ECR_REPOSITORY:latest"

          docker push "$IMAGE_URI"
          docker push "$ECR_REGISTRY/$ECR_REPOSITORY:latest"

          echo "Imágenes subidas correctamente"

  # Job final: hace el despliegue real en la instancia EC2.
  deploy_ec2:
    runs-on: ubuntu-latest
    needs: deploy
    if: {{ deploy_condition }}

    env:
      # Credenciales y configuración para entrar a la EC2 y pasar variables al docker-compose.
      AWS_ACCESS_KEY_ID: {% raw %}${{ secrets.AWS_ACCESS_KEY_ID }}{% endraw %}
      AWS_SECRET_ACCESS_KEY: {% raw %}${{ secrets.AWS_SECRET_ACCESS_KEY }}{% endraw %}
      AWS_REGION: {% raw %}${{ secrets.AWS_REGION }}{% endraw %}
      AWS_ECR_URL: {% raw %}${{ secrets.AWS_ECR_URL }}{% endraw %}
      ECR_REPOSITORY: {% raw %}${{ secrets.ECR_REPOSITORY }}{% endraw %}
      EC2_HOST: {% raw %}${{ secrets.EC2_HOST }}{% endraw %}
      EC2_USER: {% raw %}${{ secrets.EC2_USUARIO }}{% endraw %}
      EC2_LLAVE_SSH: {% raw %}${{ secrets.EC2_LLAVE_SSH }}{% endraw %}
      EC2_KNOWN_HOSTS: {% raw %}${{ secrets.EC2_KNOWN_HOSTS }}{% endraw %}

      # Variables de base de datos que luego usaré en docker-compose.
      DB_ENGINE: {% raw %}${{ secrets.DB_ENGINE }}{% endraw %}
      DB_HOST: {% raw %}${{ secrets.DB_HOST }}{% endraw %}
      DB_PORT: {% raw %}${{ secrets.DB_PORT }}{% endraw %}
      DB_NAME: {% raw %}${{ secrets.DB_NAME }}{% endraw %}
      DB_USER: {% raw %}${{ secrets.DB_USER }}{% endraw %}
      DB_PASSWORD: {% raw %}${{ secrets.DB_PASSWORD }}{% endraw %}

    steps:
      - uses: actions/checkout@v4

      - name: Preparar clave SSH
        # Aquí preparo la clave privada y known_hosts para poder conectarme sin problemas.
        run: |
          mkdir -p ~/.ssh
          printf "%s" "${EC2_LLAVE_SSH}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          if [ -n "${EC2_KNOWN_HOSTS}" ]; then
            echo "${EC2_KNOWN_HOSTS}" > ~/.ssh/known_hosts
          else
            ssh-keyscan -H "$EC2_HOST" >> ~/.ssh/known_hosts
          fi

      - name: Subir docker-compose.yml a EC2
        # Subo el docker-compose al directorio ~/app de la máquina.
        run: scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes docker-compose.yml "$EC2_USER@$EC2_HOST:~/app/docker-compose.yml"

      - name: Ejecutar despliegue en EC2
        # Aquí hago login en ECR, actualizo contenedores y limpio imágenes antiguas.
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "$EC2_USER@$EC2_HOST" "
            set -e

            export AWS_REGION='${AWS_REGION}'
            export AWS_ECR_URL='${AWS_ECR_URL}'
            export ECR_REPOSITORY='${ECR_REPOSITORY}'

            # Paso las variables de base de datos al entorno
            export DB_ENGINE='${DB_ENGINE}'
            export DB_HOST='${DB_HOST}'
            export DB_PORT='${DB_PORT}'
            export DB_NAME='${DB_NAME}'
            export DB_USER='${DB_USER}'
            export DB_PASSWORD='${DB_PASSWORD}'

            # Construyo el host del registry
            REGISTRY_NO_PROTO=\"\${AWS_ECR_URL#https://}\"
            REGISTRY_HOST=\"\${REGISTRY_NO_PROTO%/}\"

            # Imagen que usarán los servicios del docker-compose
            export IMAGE_URI=\"\${REGISTRY_HOST}/\${ECR_REPOSITORY}:latest\"

            echo 'Haciendo login en ECR desde la EC2'
            aws ecr get-login-password --region \"${AWS_REGION}\" \
              | docker login --username AWS --password-stdin \"\${REGISTRY_HOST}\"

            cd ~/app
            docker compose pull
            docker compose up -d --remove-orphans
            docker image prune -f
          "
{% endif %}