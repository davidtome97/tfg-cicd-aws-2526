name: CI-__APP_NAME__

on:
  push:
    branches: ["main"]
    tags: ["*"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python (3.10)
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # Si no tienes tests, no rompemos el pipeline
      - name: Run tests (optional)
        run: |
          if [ -d "tests" ]; then
            pip install pytest
            pytest -q
          else
            echo "No tests folder. Skipping."
          fi

  sonar:
    runs-on: ubuntu-latest
    needs: build_and_test
    steps:
      - uses: actions/checkout@v4

      - name: SonarCloud Analysis (optional)
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
          SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
        run: |
          set -euo pipefail

          if [ -z "${SONAR_TOKEN:-}" ] || [ -z "${SONAR_PROJECT_KEY:-}" ] || [ -z "${SONAR_ORGANIZATION:-}" ]; then
            echo "Sonar secrets not configured. Skipping Sonar analysis."
            exit 0
          fi

          if [ -z "${SONAR_HOST_URL:-}" ]; then
            SONAR_HOST_URL="https://sonarcloud.io"
          fi

          curl -fsSL -o sonar-scanner.zip \
            https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
          unzip -q sonar-scanner.zip

          ./sonar-scanner-*/bin/sonar-scanner \
            -Dsonar.projectKey="${SONAR_PROJECT_KEY}" \
            -Dsonar.organization="${SONAR_ORGANIZATION}" \
            -Dsonar.host.url="${SONAR_HOST_URL}" \
            -Dsonar.token="${SONAR_TOKEN}" \
            -Dsonar.sources="." \
            -Dsonar.python.version="3.10"

    continue-on-error: true

  build_and_push_ecr:
    runs-on: ubuntu-latest
    needs: build_and_test
    # Push a main y tags (NO PR)
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/'))
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push Docker image
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
        run: |
          set -euo pipefail

          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            IMAGE_TAG="${GITHUB_REF_NAME}"
          else
            IMAGE_TAG="${GITHUB_SHA}"
          fi

          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

          echo "Building image: ${IMAGE_URI}"
          docker build -t "${IMAGE_URI}" .

          echo "Pushing image..."
          docker push "${IMAGE_URI}"

          # latest solo en main
          if [[ "${GITHUB_REF}" == "refs/heads/main" ]]; then
            echo "Tagging latest..."
            docker tag "${IMAGE_URI}" "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"
            docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"
          fi

          echo "Done ✅"

  deploy_ec2:
    runs-on: ubuntu-latest
    needs: build_and_push_ecr
    if: startsWith(github.ref, 'refs/tags/')

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}

      EC2_HOST: ${{ secrets.EC2_HOST }}
      EC2_USER: ${{ secrets.EC2_USER }}
      EC2_LLAVE_SSH: ${{ secrets.EC2_LLAVE_SSH }}
      EC2_KNOWN_HOSTS: ${{ secrets.EC2_KNOWN_HOSTS }}

      # (Paso 5) NO dependen de DB. Pueden venir vacías y se pondrán defaults en EC2.
      DB_MODE: ${{ secrets.DB_MODE }}
      DB_ENGINE: ${{ secrets.DB_ENGINE }}
      DB_PORT: ${{ secrets.DB_PORT }}
      DB_NAME: ${{ secrets.DB_NAME }}
      DB_SSLMODE: ${{ secrets.DB_SSLMODE }}
      APP_PORT: ${{ secrets.APP_PORT }}

      # (Paso 6) DB remota: pueden NO existir aún. NO las usamos en Paso 5.
      DB_URI: ${{ secrets.DB_URI }}
      DB_HOST: ${{ secrets.DB_HOST }}
      DB_USER: ${{ secrets.DB_USER }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}

    steps:
      - uses: actions/checkout@v4

      - name: Preparar clave SSH
        shell: bash
        run: |
          set -e
          mkdir -p ~/.ssh
          printf "%s" "${EC2_LLAVE_SSH}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          if [ -n "${EC2_KNOWN_HOSTS}" ]; then
            printf "%s\n" "${EC2_KNOWN_HOSTS}" > ~/.ssh/known_hosts
          else
            ssh-keyscan -H "${EC2_HOST}" >> ~/.ssh/known_hosts
          fi

      - name: Subir docker-compose.yml a EC2
        shell: bash
        run: |
          set -e
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "${EC2_USER}@${EC2_HOST}" "mkdir -p ~/app"
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes docker-compose.yml "${EC2_USER}@${EC2_HOST}:~/app/docker-compose.yml"

      - name: Deploy en EC2
        shell: bash
        run: |
          set -euo pipefail
          
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            IMAGE_TAG="${GITHUB_REF_NAME}"
          else
            IMAGE_TAG="${GITHUB_SHA}"
          fi
          
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes \
            "${EC2_USER}@${EC2_HOST}" \
            AWS_REGION="${AWS_REGION}" \
            AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID}" \
            ECR_REPOSITORY="${ECR_REPOSITORY}" \
            IMAGE_TAG="${IMAGE_TAG}" \
            DB_MODE="${DB_MODE:-}" \
            DB_ENGINE="${DB_ENGINE:-}" \
            DB_PORT="${DB_PORT:-}" \
            DB_NAME="${DB_NAME:-}" \
            DB_SSLMODE="${DB_SSLMODE:-}" \
            APP_PORT="${APP_PORT:-}" \
            DB_URI="${DB_URI:-}" \
            DB_HOST="${DB_HOST:-}" \
            DB_USER="${DB_USER:-}" \
            DB_PASSWORD="${DB_PASSWORD:-}" \
            bash -se <<'EOF'
          set -euo pipefail
          
          clean() { printf '%s' "${1:-}" | tr -d '\r' | tr -d '\n'; }
          
          cd ~/app
          export COMPOSE_PROJECT_NAME="demo-python"
          
              DB_MODE_IN="$(clean "${DB_MODE:-}")"
              [ -z "$DB_MODE_IN" ] && DB_MODE_IN="local"
              case "$DB_MODE_IN" in local|remote) ;; *) echo "❌ DB_MODE inválido: $DB_MODE_IN"; exit 1;; esac
          export COMPOSE_PROFILES="$DB_MODE_IN"
          
          export DB_ENGINE="$(clean "${DB_ENGINE:-postgres}")"
          export DB_PORT="$(clean "${DB_PORT:-5432}")"
          export DB_NAME="$(clean "${DB_NAME:-demo}")"
          export APP_PORT="$(clean "${APP_PORT:-8081}")"
          export DB_SSLMODE="$(clean "${DB_SSLMODE:-disable}")"
          
          AWS_REGION_IN="$(clean "${AWS_REGION}")"
          AWS_ACCOUNT_ID_IN="$(clean "${AWS_ACCOUNT_ID}")"
          ECR_REPO_IN="$(clean "${ECR_REPOSITORY}")"
          IMAGE_TAG_IN="$(clean "${IMAGE_TAG}")"
          
          ECR_REGISTRY="${AWS_ACCOUNT_ID_IN}.dkr.ecr.${AWS_REGION_IN}.amazonaws.com"
          export IMAGE_URI="${ECR_REGISTRY}/${ECR_REPO_IN}:${IMAGE_TAG_IN}"
          
          if [ "$COMPOSE_PROFILES" = "local" ]; then
            export DB_USER="$(clean "${DB_USER:-demo}")"
            export DB_PASSWORD="$(clean "${DB_PASSWORD:-demo}")"
            export DB_HOST="$(clean "${DB_HOST:-postgres}")"
            export DB_URI="$(clean "${DB_URI:-}")"
          else
            export DB_HOST="$(clean "${DB_HOST:-__MISSING_DB_HOST__}")"
            export DB_USER="$(clean "${DB_USER:-__MISSING_DB_USER__}")"
            export DB_PASSWORD="$(clean "${DB_PASSWORD:-__MISSING_DB_PASSWORD__}")"
            export DB_URI="$(clean "${DB_URI:-__MISSING_DB_URI__}")"
          fi
          
          if [ "$COMPOSE_PROFILES" = "remote" ]; then
            if [ "$DB_ENGINE" = "mongo" ]; then
              [ "$DB_URI" != "__MISSING_DB_URI__" ] || (echo "❌ Falta DB_URI para mongo remoto" && exit 1)
              unset DB_HOST DB_PORT DB_USER DB_PASSWORD || true
            else
              [ "$DB_HOST" != "__MISSING_DB_HOST__" ] || (echo "❌ Falta DB_HOST para SQL remoto" && exit 1)
              [ "$DB_USER" != "__MISSING_DB_USER__" ] || (echo "❌ Falta DB_USER para SQL remoto" && exit 1)
              [ "$DB_PASSWORD" != "__MISSING_DB_PASSWORD__" ] || (echo "❌ Falta DB_PASSWORD para SQL remoto" && exit 1)
            fi
          fi
          
          aws ecr get-login-password --region "$AWS_REGION_IN" \
            | sudo -E docker login --username AWS --password-stdin "$ECR_REGISTRY"

          # 1) bajar stack actual
          sudo -E docker compose -p "$COMPOSE_PROJECT_NAME" -f docker-compose.yml --profile "$COMPOSE_PROFILES" down --remove-orphans || true

          # 2) liberar puerto si sigue ocupado
          PORT_IN_USE="$(sudo ss -ltnp | awk -v p=":${APP_PORT}" '$4 ~ p {print $0}' || true)"
          if [ -n "${PORT_IN_USE}" ]; then
            echo "Puerto ${APP_PORT} ya está en uso. Intentando liberar..."

            # si lo ocupa docker (0.0.0.0 o :::), paramos ese contenedor
            CID="$(sudo docker ps --format '{{.ID}} {{.Ports}}' \
              | awk -v p=":${APP_PORT}->" '$0 ~ p {print $1; exit}' || true)"

            if [ -n "${CID}" ]; then
              echo "Parando contenedor que ocupa ${APP_PORT}: ${CID}"
              sudo docker rm -f "${CID}" || true
            else
              echo "No parece ser Docker. Proceso usando el puerto:"
              sudo lsof -i :"${APP_PORT}" || true
            fi
          fi

          # 3) pull + up
          sudo -E docker compose -p "$COMPOSE_PROJECT_NAME" -f docker-compose.yml --profile "$COMPOSE_PROFILES" pull
          sudo -E docker compose -p "$COMPOSE_PROJECT_NAME" -f docker-compose.yml --profile "$COMPOSE_PROFILES" up -d --remove-orphans

          echo "Estado:"
          sudo docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}'

          EOF