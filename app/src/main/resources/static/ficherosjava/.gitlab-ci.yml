stages:
  - test
  - sonar
  - build
  - deploy

# Variables comunes (puedes sobreescribir en GitLab CI/CD Variables)
variables:
  MAVEN_OPTS: "-Dmaven.repo.local=.m2/repository"
  AWS_REGION: "${AWS_REGION}"
  AWS_ACCOUNT_ID: "${AWS_ACCOUNT_ID}"
  ECR_REPOSITORY: "${ECR_REPOSITORY}"

cache:
  paths:
    - .m2/repository

build_and_test:
  stage: test
  image: maven:3.9.9-eclipse-temurin-17
  script:
    - mvn -B -f pom.xml test
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG

sonar:
  stage: sonar
  image: maven:3.9.9-eclipse-temurin-17
  needs: ["build_and_test"]
  script:
    - |
      if [ -z "${SONAR_TOKEN}" ] || [ -z "${SONAR_PROJECT_KEY}" ] || [ -z "${SONAR_ORGANIZATION}" ]; then
        echo "Sonar variables not configured. Skipping."
        exit 0
      fi
      if [ -z "${SONAR_HOST_URL}" ]; then
        SONAR_HOST_URL="https://sonarcloud.io"
      fi
      mvn -B -f pom.xml verify org.sonarsource.scanner.maven:sonar-maven-plugin:3.11.0.3922:sonar \
        -Dsonar.projectKey="${SONAR_PROJECT_KEY}" \
        -Dsonar.organization="${SONAR_ORGANIZATION}" \
        -Dsonar.host.url="${SONAR_HOST_URL}"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG
  allow_failure: true

build_and_push_ecr:
  stage: build
  image: docker:27
  services:
    - docker:27-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - apk add --no-cache python3 py3-pip curl jq aws-cli
    - aws --version
    - docker --version
  script:
    - |
      set -e
      IMAGE_TAG="${CI_COMMIT_SHA}"
      ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
      IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

      echo "Login ECR..."
      aws ecr get-login-password --region "${AWS_REGION}" \
        | docker login --username AWS --password-stdin "${ECR_REGISTRY}"

      echo "Build ${IMAGE_URI}"
      docker build -t "${IMAGE_URI}" .

      echo "Tag latest"
      docker tag "${IMAGE_URI}" "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"

      echo "Push"
      docker push "${IMAGE_URI}"
      docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"
  rules:
    # en GitLab: en main y en tags (no MR)
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG

deploy_ec2:
  stage: deploy
  image: alpine:3.20
  needs: ["build_and_push_ecr"]
  before_script:
    - apk add --no-cache openssh-client bash curl aws-cli
    - mkdir -p ~/.ssh
    - echo "$EC2_LLAVE_SSH" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - |
      if [ -n "${EC2_KNOWN_HOSTS}" ]; then
        echo "${EC2_KNOWN_HOSTS}" > ~/.ssh/known_hosts
      else
        ssh-keyscan -H "${EC2_HOST}" >> ~/.ssh/known_hosts
      fi
  script:
    - |
      set -e

      # Subir docker-compose.yml
      ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "${EC2_USER}@${EC2_HOST}" "mkdir -p ~/app"
      scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes docker-compose.yml "${EC2_USER}@${EC2_HOST}:~/app/docker-compose.yml"

      # Deploy remoto
      ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "${EC2_USER}@${EC2_HOST}" \
        "export DB_MODE='${DB_MODE}';
         export DB_ENGINE='${DB_ENGINE}';
         export DB_PORT='${DB_PORT}';
         export DB_NAME='${DB_NAME}';
         export APP_PORT='${APP_PORT}';
         export DB_HOST='${DB_HOST}';
         export DB_USER='${DB_USER}';
         export DB_PASSWORD='${DB_PASSWORD}';
         export DB_URI='${DB_URI}';
         export AWS_REGION='${AWS_REGION}';
         export AWS_ACCOUNT_ID='${AWS_ACCOUNT_ID}';
         export ECR_REPOSITORY='${ECR_REPOSITORY}';
         export IMAGE_TAG='${CI_COMMIT_SHA}';
         bash -se" <<'EOF'
          set -euo pipefail
          clean() { printf '%s' "${1:-}" | tr -d '\r' | tr -d '\n'; }

          cd ~/app
          export COMPOSE_PROJECT_NAME="demo-java"

          DB_MODE_IN="$(clean "${DB_MODE:-local}")"
          [ -z "$DB_MODE_IN" ] && DB_MODE_IN="local"
          if [ "$DB_MODE_IN" != "local" ] && [ "$DB_MODE_IN" != "remote" ]; then
            echo "DB_MODE inválido: $DB_MODE_IN (usa local|remote)"
            exit 1
          fi
          export COMPOSE_PROFILES="$DB_MODE_IN"

          export DB_ENGINE="$(clean "${DB_ENGINE:-postgres}")"
          export DB_PORT="$(clean "${DB_PORT:-5432}")"
          export DB_NAME="$(clean "${DB_NAME:-demo}")"
          export APP_PORT="$(clean "${APP_PORT:-8082}")"

          AWS_REGION_IN="$(clean "${AWS_REGION}")"
          AWS_ACCOUNT_ID_IN="$(clean "${AWS_ACCOUNT_ID}")"
          ECR_REPO_IN="$(clean "${ECR_REPOSITORY}")"
          IMAGE_TAG_IN="$(clean "${IMAGE_TAG}")"
          ECR_REGISTRY="${AWS_ACCOUNT_ID_IN}.dkr.ecr.${AWS_REGION_IN}.amazonaws.com"
          export IMAGE_URI="${ECR_REGISTRY}/${ECR_REPO_IN}:${IMAGE_TAG_IN}"

          if [ "$COMPOSE_PROFILES" = "remote" ]; then
            if [ "$DB_ENGINE" = "mongo" ]; then
              export DB_URI="$(clean "${DB_URI:-}")"
              if [ -z "$DB_URI" ]; then
                echo "Falta variable para mongo remoto: DB_URI"
                exit 1
              fi
              unset DB_HOST DB_PORT DB_USER DB_PASSWORD || true
            else
              export DB_HOST="$(clean "${DB_HOST:-}")"
              export DB_USER="$(clean "${DB_USER:-}")"
              export DB_PASSWORD="$(clean "${DB_PASSWORD:-}")"
              if [ -z "$DB_HOST" ] || [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ]; then
                echo "Faltan variables para remote SQL: DB_HOST, DB_USER, DB_PASSWORD"
                exit 1
              fi
            fi
          else
            export DB_USER="$(clean "${DB_USER:-demo}")"
            export DB_PASSWORD="$(clean "${DB_PASSWORD:-demo}")"
          fi

          # deps mínimas
          if ! command -v aws >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y awscli
          fi
          if ! command -v docker >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y docker.io
            sudo systemctl enable --now docker
          fi
          if ! sudo docker compose version >/dev/null 2>&1; then
            sudo mkdir -p /usr/local/lib/docker/cli-plugins
            sudo curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64 \
              -o /usr/local/lib/docker/cli-plugins/docker-compose
            sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
          fi

          # login ECR + deploy
          aws ecr get-login-password --region "$AWS_REGION_IN" \
            | sudo -E docker login --username AWS --password-stdin "$ECR_REGISTRY"

          sudo -E docker compose -p "$COMPOSE_PROJECT_NAME" -f docker-compose.yml --profile "$COMPOSE_PROFILES" down --remove-orphans || true
          sudo -E docker compose -p "$COMPOSE_PROJECT_NAME" -f docker-compose.yml --profile "$COMPOSE_PROFILES" pull
          sudo -E docker compose -p "$COMPOSE_PROJECT_NAME" -f docker-compose.yml --profile "$COMPOSE_PROFILES" up -d --remove-orphans

          echo "Estado:"
          sudo docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}'
      EOF"
  rules:
    # desplegar SOLO con tags (igual que GitHub)
    - if: $CI_COMMIT_TAG