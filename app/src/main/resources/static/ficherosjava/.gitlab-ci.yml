stages:
  - test
  - sonar
  - build
  - deploy

variables:
  MAVEN_OPTS: "-Dmaven.repo.local=.m2/repository"
  GIT_DEPTH: "0"
  SONAR_HOST_URL: "https://sonarcloud.io"
  SONAR_API_URL: "https://api.sonarcloud.io"

cache:
  key: "${CI_PROJECT_NAME}"
  paths:
    - .m2/repository
    - .sonar/cache

build_and_test:
  stage: test
  image: maven:3.9.9-eclipse-temurin-17
  script:
    - mvn -B test
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG

sonar:
  stage: sonar
  image: maven:3.9.9-eclipse-temurin-17
  needs: ["build_and_test"]
  cache:
    key: "maven-${CI_COMMIT_REF_SLUG}"
    paths:
      - .m2/repository
      - .sonar/cache
  script:
    - |
      set -euo pipefail

      if [ -z "${SONAR_TOKEN:-}" ] || [ -z "${SONAR_PROJECT_KEY:-}" ] || [ -z "${SONAR_ORGANIZATION:-}" ]; then
        echo "Sonar variables not configured. Skipping."
        exit 0
      fi

      echo "Validate token:"
      curl -fsS -u "${SONAR_TOKEN}:" "${SONAR_API_URL}/api/authentication/validate" || true
      echo

      echo "Check project exists + access:"
      curl -sS -u "${SONAR_TOKEN}:" \
        "${SONAR_API_URL}/api/components/show?component=${SONAR_PROJECT_KEY}" | head -c 400; echo

      test -f pom.xml || (echo "No hay pom.xml en la raíz" && exit 1)

      # IMPORTANTE: compilar antes para que existan .class y no falle sonar.java.binaries
      mvn -B -DskipTests clean verify

      # Ejecutar el plugin de sonar de forma explícita (evita "No plugin found for prefix 'sonar'")
      mvn -B org.sonarsource.scanner.maven:sonar-maven-plugin:5.5.0.6356:sonar \
        -Dsonar.projectKey="${SONAR_PROJECT_KEY}" \
        -Dsonar.organization="${SONAR_ORGANIZATION}" \
        -Dsonar.host.url="${SONAR_HOST_URL}" \
        -Dsonar.token="${SONAR_TOKEN}"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG
  allow_failure: true

build_and_push_ecr:
  stage: build
  image: docker:27
  services:
    - docker:27-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - apk add --no-cache aws-cli curl jq
    - aws --version
    - docker --version
  script:
    - |
      set -euo pipefail

      # Validación para que no explote con -u
      : "${AWS_REGION:?Falta AWS_REGION en GitLab Variables}"
      : "${AWS_ACCOUNT_ID:?Falta AWS_ACCOUNT_ID en GitLab Variables}"
      : "${ECR_REPOSITORY:?Falta ECR_REPOSITORY en GitLab Variables}"

      # Tag de imagen: si viene de un tag Git, usa ese tag; si no, usa SHA
      if [ -n "${CI_COMMIT_TAG:-}" ]; then
        IMAGE_TAG="${CI_COMMIT_TAG}"
      else
        IMAGE_TAG="${CI_COMMIT_SHA}"
      fi

      ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
      IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

      echo "Login ECR..."
      aws ecr get-login-password --region "${AWS_REGION}" \
        | docker login --username AWS --password-stdin "${ECR_REGISTRY}"

      echo "Build ${IMAGE_URI}"
      docker build -t "${IMAGE_URI}" .

      echo "Push ${IMAGE_URI}"
      docker push "${IMAGE_URI}"

      # Solo actualiza latest si es main (opcional)
      if [ "${CI_COMMIT_BRANCH:-}" = "main" ]; then
        echo "Tag latest"
        docker tag "${IMAGE_URI}" "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"
        docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG

deploy_ec2:
  stage: deploy
  image: alpine:3.20
  needs: ["build_and_push_ecr"]

  before_script:
    - apk add --no-cache openssh-client bash curl aws-cli
    - mkdir -p ~/.ssh
    - echo "$EC2_LLAVE_SSH" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - |
      if [ -n "${EC2_KNOWN_HOSTS:-}" ]; then
        echo "${EC2_KNOWN_HOSTS}" > ~/.ssh/known_hosts
      else
        ssh-keyscan -H "${EC2_HOST}" >> ~/.ssh/known_hosts
      fi

  script:
    - |
      set -euo pipefail

      : "${AWS_REGION:?Falta AWS_REGION}"
      : "${AWS_ACCOUNT_ID:?Falta AWS_ACCOUNT_ID}"
      : "${ECR_REPOSITORY:?Falta ECR_REPOSITORY}"
      : "${EC2_HOST:?Falta EC2_HOST}"
      : "${EC2_USER:?Falta EC2_USER}"

      DB_MODE="${DB_MODE:-local}"
      DB_ENGINE="${DB_ENGINE:-mongo}"
      DB_PORT="${DB_PORT:-27017}"
      DB_NAME="${DB_NAME:-demo}"
      APP_PORT="${APP_PORT:-8082}"
      DB_HOST="${DB_HOST:-}"
      DB_USER="${DB_USER:-demo}"
      DB_PASSWORD="${DB_PASSWORD:-demo}"
      DB_URI="${DB_URI:-}"

      if [ -n "${CI_COMMIT_TAG:-}" ]; then
        IMAGE_TAG="${CI_COMMIT_TAG}"
      else
        IMAGE_TAG="${CI_COMMIT_SHA}"
      fi

      ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "${EC2_USER}@${EC2_HOST}" "mkdir -p ~/app"
      scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes docker-compose.yml "${EC2_USER}@${EC2_HOST}:~/app/docker-compose.yml"

      ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "${EC2_USER}@${EC2_HOST}" \
        DB_MODE="$DB_MODE" \
        DB_ENGINE="$DB_ENGINE" \
        DB_PORT="$DB_PORT" \
        DB_NAME="$DB_NAME" \
        APP_PORT="$APP_PORT" \
        DB_HOST="$DB_HOST" \
        DB_USER="$DB_USER" \
        DB_PASSWORD="$DB_PASSWORD" \
        DB_URI="$DB_URI" \
        AWS_REGION="$AWS_REGION" \
        AWS_ACCOUNT_ID="$AWS_ACCOUNT_ID" \
        ECR_REPOSITORY="$ECR_REPOSITORY" \
        IMAGE_TAG="$IMAGE_TAG" \
        'bash -se' <<'EOF'
      set -euo pipefail
      clean() { printf '%s' "${1:-}" | tr -d '\r' | tr -d '\n'; }

      cd ~/app
      export COMPOSE_PROJECT_NAME="demo-java"

      DB_MODE_IN="$(clean "${DB_MODE:-local}")"
      [ -z "$DB_MODE_IN" ] && DB_MODE_IN="local"
      case "$DB_MODE_IN" in local|remote) ;; *) echo "DB_MODE inválido: $DB_MODE_IN"; exit 1;; esac
      export COMPOSE_PROFILES="$DB_MODE_IN"

      export DB_ENGINE="$(clean "${DB_ENGINE:-mongo}")"
      export DB_PORT="$(clean "${DB_PORT:-27017}")"
      export DB_NAME="$(clean "${DB_NAME:-demo}")"
      export APP_PORT="$(clean "${APP_PORT:-8082}")"

      AWS_REGION_IN="$(clean "${AWS_REGION}")"
      AWS_ACCOUNT_ID_IN="$(clean "${AWS_ACCOUNT_ID}")"
      ECR_REPO_IN="$(clean "${ECR_REPOSITORY}")"
      IMAGE_TAG_IN="$(clean "${IMAGE_TAG}")"
      ECR_REGISTRY="${AWS_ACCOUNT_ID_IN}.dkr.ecr.${AWS_REGION_IN}.amazonaws.com"
      export IMAGE_URI="${ECR_REGISTRY}/${ECR_REPO_IN}:${IMAGE_TAG_IN}"

      if [ "$COMPOSE_PROFILES" = "remote" ]; then
        if [ "$DB_ENGINE" = "mongo" ]; then
          export DB_URI="$(clean "${DB_URI:-}")"
          [ -n "$DB_URI" ] || (echo "Falta DB_URI para mongo remoto" && exit 1)
          unset DB_HOST DB_PORT DB_USER DB_PASSWORD || true
        else
          export DB_HOST="$(clean "${DB_HOST:-}")"
          export DB_USER="$(clean "${DB_USER:-}")"
          export DB_PASSWORD="$(clean "${DB_PASSWORD:-}")"
          [ -n "$DB_HOST" ] && [ -n "$DB_USER" ] && [ -n "$DB_PASSWORD" ] || (echo "Faltan DB_HOST/DB_USER/DB_PASSWORD para SQL remoto" && exit 1)
        fi
      else
        export DB_USER="$(clean "${DB_USER:-demo}")"
        export DB_PASSWORD="$(clean "${DB_PASSWORD:-demo}")"
      fi

      aws ecr get-login-password --region "$AWS_REGION_IN" \
        | sudo -E docker login --username AWS --password-stdin "$ECR_REGISTRY"

      echo "Liberando puerto APP_PORT=${APP_PORT} si está ocupado..."
      sudo docker ps --format '{{.ID}} {{.Ports}}' | awk -v p=":${APP_PORT}->" '$0 ~ p {print $1}' | xargs -r sudo docker rm -f || true

      sudo -E docker compose -p "$COMPOSE_PROJECT_NAME" -f docker-compose.yml --profile "$COMPOSE_PROFILES" down --remove-orphans || true
      sudo -E docker compose -p "$COMPOSE_PROJECT_NAME" -f docker-compose.yml --profile "$COMPOSE_PROFILES" pull
      sudo -E docker compose -p "$COMPOSE_PROJECT_NAME" -f docker-compose.yml --profile "$COMPOSE_PROFILES" up -d --remove-orphans

      echo "Estado:"
      sudo docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}'
      EOF

  rules:
    - if: $CI_COMMIT_TAG