# Aquí defino cuándo quiero que se ejecute mi pipeline en GitLab.
workflow:
  rules:
    # Si en el generador activé que se ejecute en MRs, añado esta regla.

    # Siempre la ejecuto cuando hay un push a cualquier rama.
    - if: '$CI_COMMIT_BRANCH'
    # Si no se cumple ninguna de las reglas anteriores, no lanzo nada.
    - when: never

# Los stages que voy a usar a lo largo de toda la pipeline.
stages:
  - build
  - test
  - sonar
  - deploy

# Variables globales compartidas entre jobs.
variables:
  # Uso el SHA corto como tag de imagen para identificar cada build.
  IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"

  # Si estoy usando AWS, todas estas variables deben estar ya definidas en GitLab CI/CD:
  # AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION,
  # AWS_ECR_URL, ECR_REPOSITORY, EC2_HOST, EC2_USUARIO...

  # Variables genéricas para bases de datos (las creo yo en GitLab CI/CD según cada caso).

# Valores por defecto para todos los jobs.
default:
  retry: 1
  before_script:
    # Esto lo imprimo siempre para tener más contexto en los logs.
    - echo "Estoy en la rama $CI_COMMIT_BRANCH con commit $CI_COMMIT_SHORT_SHA"

# Job sencillo para que quede claro que la pipeline arrancó bien.
pipeline_ok:
  stage: build
  script:
    - echo "Pipeline iniciado correctamente"

# ------------------------- JAVA / MAVEN -------------------------

build_java:
  stage: build
  image: maven:3.9.9-eclipse-temurin-17
  script:
    - echo "Compilando proyecto Java con Maven..."
    - ./mvnw -B -f pom.xml clean package

test_java:
  stage: test
  image: maven:3.9.9-eclipse-temurin-17
  # Quiero que este job se ejecute después del build.
  needs: ["build_java"]
  script:
    - echo "Ejecutando tests de Maven..."
    - ./mvnw -B -f pom.xml test


sonar:
  stage: sonar
  image: maven:3.9.9-eclipse-temurin-17
  needs: ["test_java"]
  script:
    - echo "Lanzando análisis de SonarCloud..."
    - ./mvnw -B -f pom.xml verify sonar:sonar \
      -Dsonar.projectKey="$SONAR_PROJECT_KEY" \
      -Dsonar.organization="$SONAR_ORGANIZATION" \
      -Dsonar.host.url="$SONAR_HOST_URL" \
      -Dsonar.login="$SONAR_TOKEN"


# -------------- Build Docker + Push a ECR + Deploy en EC2 --------------

build_and_push:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    # Configuración típica necesaria cuando uso docker-in-docker.
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2
  rules:
    # Reglas de ejecución según el modo de despliegue que haya elegido.

    - if: '$CI_COMMIT_TAG'

  script:
    - echo "Instalo AWS CLI para poder interactuar con ECR"
    - apk add --no-cache bash curl jq python3 py3-pip unzip
    - python3 -m venv /tmp/awscli && . /tmp/awscli/bin/activate
    - pip install --no-cache-dir awscli
    - export PATH="/tmp/awscli/bin:$PATH"
    - aws --version

    # Quito el protocolo de la URL del registry para que Docker lo acepte.
    - REGISTRY_NO_PROTO="${AWS_ECR_URL#https://}"
    - REGISTRY_HOST="${REGISTRY_NO_PROTO%/}"

    # Compruebo si el repositorio existe en ECR; si no, lo creo.
    - |
      echo "Verifico repositorio ECR..."
      if ! aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" --region "$AWS_REGION" >/dev/null 2>&1; then
        aws ecr create-repository --repository-name "$ECR_REPOSITORY" --region "$AWS_REGION" || true
      fi

    # Login en ECR para poder subir imágenes.
    - aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$REGISTRY_HOST"

    # Construyo la imagen y le añado dos tags: el SHA y latest.
    - docker build -t "$REGISTRY_HOST/$ECR_REPOSITORY:$IMAGE_TAG" .
    - docker tag "$REGISTRY_HOST/$ECR_REPOSITORY:$IMAGE_TAG" "$REGISTRY_HOST/$ECR_REPOSITORY:latest"

    # Subo ambas imágenes a ECR.
    - docker push "$REGISTRY_HOST/$ECR_REPOSITORY:$IMAGE_TAG"
    - docker push "$REGISTRY_HOST/$ECR_REPOSITORY:latest"

deploy_ec2:
  stage: deploy
  image: alpine:3.20
  rules:
    # Mismas reglas de ejecución que en el job anterior.

    - if: '$CI_COMMIT_TAG'


  before_script:
    # Instalo lo básico para SSH, AWS y despliegue.
    - apk add --no-cache bash curl jq openssh-client python3 py3-pip
    - python3 -m venv /tmp/awscli && . /tmp/awscli/bin/activate
    - pip install --no-cache-dir awscli
    - aws --version

    # Preparo la clave privada para hacer SSH a la EC2.
    - mkdir -p ~/.ssh
    - |
      if [ -f "$EC2_LLAVE_SSH" ]; then
        # Si la clave es un archivo, la copio.
        cp "$EC2_LLAVE_SSH" ~/.ssh/id_rsa
      else
        # Si es una variable con contenido, la escribo.
        printf "%s" "$EC2_LLAVE_SSH" > ~/.ssh/id_rsa
      fi
    - chmod 600 ~/.ssh/id_rsa

    # Preparo el known_hosts.
    - |
      if [ -n "$EC2_KNOWN_HOSTS" ]; then
        printf "%s\n" "$EC2_KNOWN_HOSTS" > ~/.ssh/known_hosts
      else
        ssh-keyscan -H "$EC2_HOST" >> ~/.ssh/known_hosts
      fi

  script:
    - echo "Inicio despliegue en EC2"

    # Aseguro que existe el directorio en la máquina para subir el compose.
    - ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "${EC2_USER}@${EC2_HOST}" "mkdir -p ~/app"

    # Subo el docker-compose.yml al servidor.
    - scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes docker-compose.yml "${EC2_USER}@${EC2_HOST}:/home/${EC2_USER}/app/docker-compose.yml"

    - |
      # Ahora ejecuto el despliegue completo dentro de la EC2.
      ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "${EC2_USER}@${EC2_HOST}" "
      set -e

      # Exporto todas las variables necesarias dentro de la EC2.
      export AWS_ACCESS_KEY_ID='${AWS_ACCESS_KEY_ID}'
      export AWS_SECRET_ACCESS_KEY='${AWS_SECRET_ACCESS_KEY}'
      export AWS_REGION='${AWS_REGION}'
      export AWS_ECR_URL='${AWS_ECR_URL}'
      export ECR_REPOSITORY='${ECR_REPOSITORY}'

      # Configuración de base de datos para la app.
      export DB_ENGINE='${DB_ENGINE:-postgresql}'
      export DB_HOST='${DB_HOST:-postgres-db}'
      export DB_PORT='${DB_PORT:-5432}'
      export DB_NAME='${DB_NAME:-tfg}'
      export DB_USER='${DB_USER:-tfg}'
      export DB_PASSWORD='${DB_PASSWORD:-tfg}'

      # Normalizo la URL del registry.
      REGISTRY_NO_PROTO=\"\${AWS_ECR_URL#https://}\"
      REGISTRY_HOST=\"\${REGISTRY_NO_PROTO%/}\"
      export IMAGE_URI=\"\${REGISTRY_HOST}/\${ECR_REPOSITORY}:latest\"

      echo 'Login en ECR'
      aws ecr get-login-password --region \"${AWS_REGION}\" \
          | docker login --username AWS --password-stdin \"\${REGISTRY_HOST}\"

      # Actualizo contenedores y limpio imágenes antiguas.
      cd ~/app
      docker compose pull
      docker compose up -d --remove-orphans
      docker image prune -f
      "

  environment:
    # Indico que este despliegue corresponde al entorno de producción.
    name: production
