# Pipeline CI/CD completo en GitLab
# Yo quiero: build/test/sonar siempre que aplique; construir imagen + deploy solo en main o tags.

# ========== ETAPAS ==========
stages:
  - build
  - test
  - sonar
  - deploy

# ========== PREAJUSTES ==========
default:
  retry: 1
  before_script:
    # Quiero ver claramente qué commit/rama ha lanzado el job
    - echo "Estoy en la rama $CI_COMMIT_BRANCH con commit $CI_COMMIT_SHORT_SHA"

cache:
  key: maven
  paths:
    - .m2/repository

# ========== “PING” DEL PIPELINE ==========
pipeline_ok:
  stage: build
  script:
    - echo "Arranco el pipeline correctamente"

# ===================== JAVA / MAVEN =====================
build_java:
  stage: build
  image: maven:3.9-eclipse-temurin-21
  rules:
    - exists: [pom.xml]
  script:
    - echo "Compilo el proyecto Maven…"
    - mvn -B -DskipTests package
  artifacts:
    when: always
    paths:
      - target/*.jar
    expire_in: 1 week

test_java:
  stage: test
  image: maven:3.9-eclipse-temurin-21
  rules:
    - exists: [pom.xml]
  script:
    - echo "Ejecuto los tests de Maven…"
    - mvn -B -DfailIfNoTests=false -Dmaven.test.failure.ignore=true test
  artifacts:
    when: always
    reports:
      junit: "**/target/surefire-reports/*.xml"

sonar_java:
  stage: sonar
  image: maven:3.9-eclipse-temurin-21
  rules:
    # No quiero que Sonar se ejecute en MRs para evitar 404/PR decoration
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: never
    # Solo analizo si tengo credenciales y hay pom.xml
    - if: '$SONAR_HOST_URL && $SONAR_TOKEN && $SONAR_PROJECT_KEY && $SONAR_ORGANIZATION'
      exists: [pom.xml]
  script:
    - echo "Genero jacoco y analizo con SonarCloud (branch/tag)"
    - mvn -B clean verify -DfailIfNoTests=false -Dmaven.test.failure.ignore=true
    - >
      mvn -B sonar:sonar
      -Dsonar.host.url="$SONAR_HOST_URL"
      -Dsonar.login="$SONAR_TOKEN"
      -Dsonar.organization="$SONAR_ORGANIZATION"
      -Dsonar.projectKey="$SONAR_PROJECT_KEY"
      -Dsonar.coverage.jacoco.xmlReportPaths="**/target/site/jacoco/jacoco.xml"

# ===================== NODE.JS (opcional si existe package.json) =====================
build_node:
  stage: build
  image: node:20
  rules:
    - exists: [package.json]
  script:
    - echo "Instalo dependencias de Node"
    - npm ci || npm install
    - echo "Ejecuto el build si existe"
    - npm run build || echo "No hay script build, sigo"
  artifacts:
    when: always
    paths:
      - dist/
      - build/
    expire_in: 1 week

test_node:
  stage: test
  image: node:20
  rules:
    - exists: [package.json]
  script:
    - echo "Lanzo los tests de Node"
    - npm ci || npm install
    - npm test -- --ci || npm test || echo "No tengo tests definidos, sigo"

sonar_node:
  stage: sonar
  image: sonarsource/sonar-scanner-cli:latest
  allow_failure: true      # Si falla Sonar en Node, no tiro el pipeline entero
  rules:
    - if: '$SONAR_HOST_URL && $SONAR_TOKEN && $SONAR_PROJECT_KEY'
      exists: [package.json]
  script: |
    echo "Analizo el código (Node) en SonarQube…"
    sonar-scanner \
      -Dsonar.projectKey="$SONAR_PROJECT_KEY" \
      -Dsonar.sources=. \
      -Dsonar.host.url="$SONAR_HOST_URL" \
      -Dsonar.login="$SONAR_TOKEN"

# ===================== DOCKER/ECR + DEPLOY EC2 =====================
# Variables que espero tener en GitLab:
#  AWS_ACCESS_KEY_ID / AWS_SECRET_ACCESS_KEY / AWS_REGION
#  AWS_ECR_URL (p.ej. 123456789012.dkr.ecr.eu-west-1.amazonaws.com)
#  ECR_REPOSITORY (p.ej. tfg-app)
#  EC2_HOST / EC2_USER / EC2_SSH_KEY(file) / EC2_KNOWN_HOSTS(opcional)

variables:
  ECR_REGISTRY: "$AWS_ECR_URL"
  IMAGE_TAG: "${CI_COMMIT_SHORT_SHA}"

# --- Construyo y subo la imagen a ECR ---
build_and_push:
  stage: build
  image: docker:24
  services: ["docker:24-dind"]
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2
  rules:
    # Solo construyo/publico cuando voy a desplegar: push a main o tags
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'
  script:
    - echo "Instalo AWS CLI en virtualenv para esquivar PEP 668"
    - apk add --no-cache bash curl jq python3 py3-pip unzip
    - python3 -m venv /tmp/awscli
    - . /tmp/awscli/bin/activate
    - pip install --no-cache-dir awscli
    - aws --version

    - echo "Compruebo/creo el repo ECR ($ECR_REPOSITORY) en $AWS_REGION"
    - aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" --region "$AWS_REGION" >/dev/null 2>&1 || aws ecr create-repository --repository-name "$ECR_REPOSITORY" --region "$AWS_REGION" >/dev/null

    - echo "Hago login en ECR"
    - aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"

    - echo "Construyo la imagen Docker"
    - docker build -t "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" .
    - docker tag "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" "$ECR_REGISTRY/$ECR_REPOSITORY:latest"

    - echo "Subo la imagen a ECR"
    - docker push "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
    - docker push "$ECR_REGISTRY/$ECR_REPOSITORY:latest"

# --- Despliegue en EC2 ---
deploy_ec2:
  stage: deploy
  image: alpine:3.20
  # No uso "needs" para que respeten el orden de stages: build -> test -> sonar -> deploy
  rules:
    # Solo despliego en push a main o en tags. No despliego en MRs.
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'
  before_script:
    - apk add --no-cache bash curl jq openssh-client python3 py3-pip
    # Uso virtualenv también aquí
    - python3 -m venv /tmp/awscli
    - . /tmp/awscli/bin/activate
    - pip install --no-cache-dir awscli
    - aws --version
    # Preparo SSH
    - mkdir -p ~/.ssh
    - cp "$EC2_SSH_KEY" ~/.ssh/id_rsa && chmod 600 ~/.ssh/id_rsa
    - |
      if [ -n "$EC2_KNOWN_HOSTS" ]; then
        echo "$EC2_KNOWN_HOSTS" > ~/.ssh/known_hosts
      else
        ssh-keyscan -H "$EC2_HOST" >> ~/.ssh/known_hosts
      fi
  script: |
    echo "Inicio el despliegue en EC2"
    # 0) Aseguro la carpeta destino
    ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes ${EC2_USER}@${EC2_HOST} 'mkdir -p ~/app'

    # 1) Subo/actualizo el docker-compose.yml
    scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes docker-compose.yml ${EC2_USER}@${EC2_HOST}:/home/${EC2_USER}/app/docker-compose.yml

    # 2) Despliegue remoto
    ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes ${EC2_USER}@${EC2_HOST} '
      set -e
      export AWS_ACCESS_KEY_ID="'$AWS_ACCESS_KEY_ID'"
      export AWS_SECRET_ACCESS_KEY="'$AWS_SECRET_ACCESS_KEY'"
      export AWS_REGION="'$AWS_REGION'"
      export IMAGE_URI="'$ECR_REGISTRY'/'$ECR_REPOSITORY':latest

      echo "Hago login en ECR desde la instancia"
      aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "'$ECR_REGISTRY'"

      cd ~/app
      if ! docker compose version >/dev/null 2>&1; then
        echo "No tengo Docker Compose v2 instalado en la AMI"; exit 1
      fi

      echo "Descargo la nueva imagen y levanto los servicios"
      docker compose pull
      docker compose up -d --remove-orphans

      echo "Limpio imágenes antiguas"
      docker image prune -f
    '
  environment:
    name: production