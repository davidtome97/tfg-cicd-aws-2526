# ---------- PIPELINE SCOPE ----------
workflow:
  rules:
    # Defino cuándo se dispara la pipeline.
    # Quiero que se ejecute también en MRs para validar build y test, pero OJO:
    # he movido Sonar para que NO corra en MRs (ver jobs sonar_* abajo).
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    # Y también cuando hago push a cualquier rama (build/test siempre).
    - if: '$CI_COMMIT_BRANCH'
    # Si nada aplica, no ejecuto nada.
    - when: never

# ---------- STAGES ----------
# Declaro los stages de mi pipeline (cada job cae en uno de estos).
stages:
  - build
  - test
  - sonar
  - deploy

# ---------- DEFAULTS ----------
# Valores comunes a todos los jobs.
default:
  retry: 1   # Si falla por algo puntual, reintento una vez.
  before_script:
    # Me imprime rama y commit para orientarme en logs.
    - echo "Estoy en la rama $CI_COMMIT_BRANCH con commit $CI_COMMIT_SHORT_SHA"

# ---------- JOB SENTINELA ----------
# Pequeño “ping” para ver que arranca todo.
pipeline_ok:
  stage: build
  script:
    - echo "Pipeline iniciado correctamente"

# ===================== JAVA / MAVEN =====================
# Compilo proyectos Java con Maven.
build_java:
  stage: build
  image: maven:3.9-eclipse-temurin-21  # Lleva Maven + Java 21.
  rules:
    - exists:
        - pom.xml   # Solo si hay pom.xml.
  script:
    - echo "Compilando proyecto Maven..."
    - mvn -B -DskipTests package  # Compilo sin tests aquí para ir rápido.
  artifacts:
    when: always
    paths:
      - target/*.jar  # Guardo el JAR para stages posteriores.
    expire_in: 1 week

# Aquí ya lanzo los tests de Maven.
test_java:
  stage: test
  image: maven:3.9-eclipse-temurin-21
  needs: [build_java]  # Depende de build_java.
  rules:
    - exists:
        - pom.xml
  script:
    - echo "Ejecutando tests Maven..."
    - mvn -B -DfailIfNoTests=false -Dmaven.test.failure.ignore=true test
  artifacts:
    when: always
    reports:
      junit:
        - "**/target/surefire-reports/*.xml"  # Subo los JUnit para el informe.

# Análisis de calidad con SonarCloud para Java.
# IMPORTANTE: he decidido NO ejecutar Sonar en MRs para evitar el 404 de "PR Decoration".
# Solo analizo en pushes a develop/main y en tags.
sonar_java:
  stage: sonar
  image: maven:3.9-eclipse-temurin-21
  rules:
    # Solo si hay variables de Sonar y es push a develop/main o es un tag.
    - if: '$SONAR_HOST_URL && $SONAR_TOKEN && $SONAR_PROJECT_KEY && $SONAR_ORGANIZATION && $CI_PIPELINE_SOURCE == "push" && ($CI_COMMIT_BRANCH == "develop" || $CI_COMMIT_BRANCH == "main")'
      exists:
        - pom.xml
    - if: '$SONAR_HOST_URL && $SONAR_TOKEN && $SONAR_PROJECT_KEY && $SONAR_ORGANIZATION && $CI_COMMIT_TAG'
      exists:
        - pom.xml
    - when: never
  script:
    - echo "Ejecuto verify para generar jacoco.xml y clases compiladas"
    - mvn -B clean verify -DfailIfNoTests=false -Dmaven.test.failure.ignore=true
    - echo "Analizo con SonarCloud (rama/tag)"
    - >
      mvn -B sonar:sonar
      -Dsonar.host.url="$SONAR_HOST_URL"
      -Dsonar.login="$SONAR_TOKEN"
      -Dsonar.organization="$SONAR_ORGANIZATION"
      -Dsonar.projectKey="$SONAR_PROJECT_KEY"
      -Dsonar.coverage.jacoco.xmlReportPaths="**/target/site/jacoco/jacoco.xml"

# ===================== NODE.JS =====================
# Build para Node.js.
build_node:
  stage: build
  image: node:20
  rules:
    - exists:
        - package.json  # Solo si hay Node.
  script:
    - echo "Instalo dependencias de Node…"
    - npm ci || npm install
    - echo "Ejecuto build si existe…"
    - npm run build || echo "No hay script build, continúo"
  artifacts:
    when: always
    paths:
      - dist/
      - build/
    expire_in: 1 week

# Tests de Node.js.
test_node:
  stage: test
  image: node:20
  needs: [build_node]
  rules:
    - exists:
        - package.json
  script:
    - echo "Lanzo tests de Node…"
    - npm ci || npm install
    - npm test -- --ci || npm test || echo "Sin tests definidos, continúo"

# Análisis Sonar para Node.js (mismo criterio que Java: no en MR).
sonar_node:
  stage: sonar
  image: sonarsource/sonar-scanner-cli:latest
  rules:
    - if: '$SONAR_HOST_URL && $SONAR_TOKEN && $SONAR_PROJECT_KEY && $CI_PIPELINE_SOURCE == "push" && ($CI_COMMIT_BRANCH == "develop" || $CI_COMMIT_BRANCH == "main")'
      exists:
        - package.json
    - if: '$SONAR_HOST_URL && $SONAR_TOKEN && $SONAR_PROJECT_KEY && $CI_COMMIT_TAG'
      exists:
        - package.json
    - when: never
  script:
    - echo "Analizo código con SonarCloud (Node)…"
    - >
      sonar-scanner
      -Dsonar.projectKey="$SONAR_PROJECT_KEY"
      -Dsonar.sources=.
      -Dsonar.host.url="$SONAR_HOST_URL"
      -Dsonar.login="$SONAR_TOKEN"

# ---------- DEPLOY MANUAL ----------
# Mantengo este job manual como “placeholder” por si quiero disparar algo a mano.
deploy:
  stage: deploy
  when: manual
  script:
    - echo "Deploy pendiente — se implementará en la tarjeta F3-4 (EC2/ECS)"

# ===================== FASE 3-4 — Build & Push a ECR + Deploy en EC2 =====================
variables:
  ECR_REGISTRY: "$AWS_ECR_URL"       # Mi registro ECR en AWS.
  IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"  # Etiqueto la imagen con el short SHA.

# --- Build & Push a ECR ---
# Construyo la imagen y la subo a ECR solo en main/tags.
build_and_push:
  stage: build
  image: docker:24
  services:
    - docker:24-dind  # Necesito Docker-in-Docker para build/push.
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'
    - when: never
  script:
    - echo "Instalo dependencias y AWS CLI"
    - apk add --no-cache bash curl jq python3 py3-pip unzip
    - python3 -m venv /tmp/awscli && . /tmp/awscli/bin/activate
    - pip install --no-cache-dir awscli
    - aws --version
    # Creo el repo ECR si no existe (lo hago silencioso para no romper si ya existe).
    - bash -lc 'aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" --region "$AWS_REGION" >/dev/null 2>&1 || aws ecr create-repository --repository-name "$ECR_REPOSITORY" --region "$AWS_REGION" >/dev/null'
    - echo "Login en ECR"
    - aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"
    - echo "Build de la imagen"
    - docker build -t "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" .
    - docker tag "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" "$ECR_REGISTRY/$ECR_REPOSITORY:latest"
    - echo "Push de la imagen"
    - docker push "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
    - docker push "$ECR_REGISTRY/$ECR_REPOSITORY:latest"

# --- Deploy en EC2 ---
# Despliego automáticamente en EC2 en main/tags.
deploy_ec2:
  stage: deploy
  image: alpine:3.20
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'
    - when: never
  before_script:
    - apk add --no-cache bash curl jq openssh-client python3 py3-pip
    - python3 -m venv /tmp/awscli && . /tmp/awscli/bin/activate
    - pip install --no-cache-dir awscli
    - aws --version
    - mkdir -p ~/.ssh
    # Preparo la clave SSH: si viene como ruta, copio; si viene como contenido, la escribo.
    - |
      if [ -f "$EC2_SSH_KEY" ]; then
        cp "$EC2_SSH_KEY" ~/.ssh/id_rsa
      else
        printf "%s" "$EC2_SSH_KEY" > ~/.ssh/id_rsa
      fi
    - chmod 600 ~/.ssh/id_rsa
    # Conocidos del host: uso variable o hago keyscan.
    - |
      if [ -n "$EC2_KNOWN_HOSTS" ]; then
        printf "%s\n" "$EC2_KNOWN_HOSTS" > ~/.ssh/known_hosts
      else
        ssh-keyscan -H "$EC2_HOST" >> ~/.ssh/known_hosts
      fi
  script:
    - echo "Inicio despliegue en EC2"
    # Creo el directorio remoto de la app si no existe.
    - ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "${EC2_USER}@${EC2_HOST}" "mkdir -p ~/app"
    # Copio el docker-compose al servidor.
    - scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes docker-compose.yml "${EC2_USER}@${EC2_HOST}:/home/${EC2_USER}/app/docker-compose.yml"
    # Ejecuto la actualización de servicios.
    - >
      ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes "${EC2_USER}@${EC2_HOST}" "
      set -e
      export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
      export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
      export AWS_REGION=${AWS_REGION}
      export IMAGE_URI=${ECR_REGISTRY}/${ECR_REPOSITORY}:latest

      echo 'Login en ECR desde la instancia'
      aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}

      cd ~/app
      if ! docker compose version >/dev/null 2>&1; then
        echo 'ERROR: falta Docker Compose v2 en la AMI'
        exit 1
      fi

      echo 'Actualizo servicios con la nueva imagen'
      docker compose pull
      docker compose up -d --remove-orphans

      echo 'Limpio imágenes antiguas'
      docker image prune -f
      "
  environment:
    name: production  # Marco que esto es producción.